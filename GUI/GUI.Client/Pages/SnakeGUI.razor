@page "/snake"
@rendermode InteractiveServer
@using Blazor.Extensions
@using Blazor.Extensions.Canvas
@using Blazor.Extensions.Canvas.Canvas2D
@using System.Numerics
@using System.Diagnostics
@using System.Text.Json
@using GUI.Client.Controllers
@using GUI.Client.Models
@inject IJSRuntime JsRuntime;

<PageTitle>Snake</PageTitle>

<!-- Connection Inputs -->
<div id="ConnectionInputs">
    <div class="input-row">

        <label for="playerName">Player Name: </label>
        <input id="playerName" type="text" @bind="playerName" disabled="@connection.IsConnected" />

        <label for="ServerNameOrAddress">Server Address: </label>
        <input id="ServerNameOrAddress" type="text" @bind="ServerNameOrAddress" disabled="@connection.IsConnected" />

        <label for="ServerPort">Port: </label>
        <input id="ServerPort" type="number" @bind="ServerPort" disabled="@connection.IsConnected" />

        @if (connection.IsConnected)
        {
            <button class="btn btn-primary" @onclick="DisconnectFromServer">Disconnect</button>
        }
        else
        {
            <button class="btn btn-primary" @onclick="ConnectToServer">Connect</button>
        }

    </div>
</div>

<br />

<!-- Background Image -->
<div>
    <img @ref="backgroundImage" id="bgImage" src="images/Background.png" alt="image" style="display:none;" />
</div>

<!-- Canvas for Game Display -->
<div id="snakeCanvas" style="position: fixed; width: 100%; height: 100%">
    <BECanvas Width="1000" Height="1000" @ref="canvasReference"></BECanvas>
</div>

<!-- Connection -->
@code
{

    private string ServerNameOrAddress = "localhost";
    private int ServerPort = 11000;
    private NetworkConnection connection = new NetworkConnection();
    private string playerName;
    private NetworkController networkController;

    private async Task ConnectToServer()
    {
        Console.WriteLine("ConnectToServer()");

        if (!connection.IsConnected)
        {
            try
            {
                // Establish connection to server
                connection.Connect(ServerNameOrAddress, ServerPort);

                // Send PlayerName to server
                connection.Send(playerName);

                // Create a NetworkController using the NetworkConnection instance
                networkController = new NetworkController(connection, playerName);

                // Start the network loop to continuously receive data
                await NetworkLoop();
            }
            catch (Exception ex)
            {
                Console.WriteLine("Error in ConnectToServer: " + ex.Message);
                throw;
            }
        }
    }

    private void DisconnectFromServer()
    {
        Console.WriteLine("DisconnectFromServer()");

        if (connection.IsConnected)
        {
            connection.Disconnect();
        }
    }

    private async Task NetworkLoop()
    {
        Console.WriteLine("NetworkLoop()");

        while (connection.IsConnected)
        {
            try
            {
                // Start receiving data from the server
                await networkController.ReceiveFromServerAsync();
            }
            catch (Exception ex)
            {
                Console.WriteLine("Error in NetworkLoop: " + ex.Message);
                break;
            }
        }
    }

}

<!-- Rendering Game State -->
@code
{

    private BECanvasComponent canvasReference = null!;
    private Canvas2DContext context = null!;
    private ElementReference backgroundImage;
    private IJSObjectReference jsModule = null!;
    private const int viewSize = 1000;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            jsModule = await JsRuntime.InvokeAsync<IJSObjectReference>("import", "./Pages/SnakeGUI.razor.js");
            this.context = await this.canvasReference.CreateCanvas2DAsync();
            await JsRuntime.InvokeAsync<object>("initRenderJS", DotNetObjectReference.Create(this));
        }

        else if (connection.IsConnected)
        {
            // Start the game loop
            // Dont want to await because OnAfterRenderAsync would never return
            GameLoopAsync();
        }
    }

    private async Task GameLoopAsync()
    {
        while (networkController.theWorld == null)
        {
            Console.WriteLine("Waiting for the world to be initialized...");
            await Task.Delay(100); // Wait for 100ms before checking again
        }

        while (true)
        {

            // Create a copy of the world to pass to DrawFrameAsync
            World snapshot = new World(networkController.theWorld);

            await DrawFrameAsync(snapshot);

            // Control the frame rate, sleep for every iteration of loop
            Thread.Sleep(20);
        }
    }

    private async Task DrawFrameAsync(World snapshot)
    {
        // clip the view so that objects drawn outside the canvas will not be shown
        await context.BeginPathAsync();
        await context.RectAsync(0, 0, viewSize, viewSize);
        await context.ClipAsync();

        // Because we are modifying the transformation matrix, we need to save it so we can restore it at the end
        await context.SaveAsync();

        // Head of the snake
        Point2D head = new Point2D(0, 0);

        // Center on origin, move to center of view port
        await context.TranslateAsync(viewSize / 2, viewSize / 2);
        await context.TranslateAsync(-head.X, -head.Y);

        // Draw the background:
        await context.DrawImageAsync(backgroundImage, -snapshot.WorldSize / 2, -snapshot.WorldSize / 2, snapshot.WorldSize, snapshot.WorldSize);

        // Draw walls
        await DrawWallsAsync(snapshot);

        // Draw snake
        await DrawSnakeAsync(snapshot);

        // Draw powerups
        await DrawPowerupsAsync(snapshot);

        await context.RestoreAsync();

        // Finish batch drawing
        await context.EndBatchAsync();

        // Must do this whenever something changes the way it needs to be displayed
        StateHasChanged();
    }

    private async Task DrawSnakeAsync(World snapshot)
    {
        // Set the fill color for the body of the snake (green)
        await context.SetFillStyleAsync("rgb(0, 255, 0)");

        // Loop through each part of the snake's body
        foreach (var snake in snapshot.Snakes.Values)
        {
            // Loop through each body part in the snake (body list)
            for (int i = 0; i < snake.SnakeBody.Count; i++)
            {
                var segment = snake.SnakeBody[i];

                // Check if this is the last segment (snake's head)
                if (i == snake.SnakeBody.Count - 1)
                {
                    // Set a different color for the head
                    await context.SetFillStyleAsync("rgb(255, 0, 0)");  // Red color for the head
                }
                else
                {
                    // Set the body color (green)
                    await context.SetFillStyleAsync("rgb(0, 255, 0)");
                }

                // Draw each segment of the snake as a circle (or square)
                await context.BeginPathAsync();
                await context.ArcAsync(segment.X, segment.Y, 10, 0, 2 * Math.PI);  // Draw circle at (X, Y) with radius 10
                await context.FillAsync();  // Fill the circle with the current fill style
            }
        }
    }

    private async Task DrawWallsAsync(World snapshot)
    {
        foreach (Wall wall in snapshot.Walls.Values)
        {
            // Get the coordinates of the wall (top-left and bottom-right corners)
            int startX = wall.P1.X;
            int startY = wall.P1.Y;
            int width = Math.Abs(wall.P2.X - wall.P1.X);  // Width is the difference in X
            int height = Math.Abs(wall.P2.Y - wall.P1.Y); // Height is the difference in Y

            // Draw a filled rectangle for each wall
            await context.FillRectAsync(startX, startY, width, height);
        }
    }

    private async Task DrawPowerupsAsync(World snapshot)
    {
        foreach (Powerup powerup in snapshot.Powerups.Values)
        {
            await context.SetLineWidthAsync(5);
            await context.SetStrokeStyleAsync($"rgb( 255, 255, 0 )");
            await context.BeginPathAsync();
            await context.ArcAsync(powerup.PowerupLocation.X, powerup.PowerupLocation.Y, 3, 0, 2 * Math.PI);
            await context.StrokeAsync();
        }
    }

}

<!-- User Input -->
@code
{

    [JSInvokable]
    public void HandleKeyPress(string key)
    {
        // Only works if IsConnected
        if (!connection.IsConnected)
        {
            return;
        }

        networkController.KeyPressCommand(key);
    }

}