@page "/snake"
@rendermode InteractiveServer
@using Blazor.Extensions
@using Blazor.Extensions.Canvas
@using Blazor.Extensions.Canvas.Canvas2D
@using System.Numerics
@using System.Diagnostics
@using System.Text.Json
@using GUI.Client.Controllers
@using GUI.Client.Models
@inject IJSRuntime JsRuntime;

<PageTitle>Snake</PageTitle>

<!-- Connection Inputs -->
<div id="ConnectionInputs">
    <div class="input-row">

        <label for="PlayerName">Player Name: </label>
        <input id="PlayerName" type="text" @bind="PlayerName" disabled="@network.IsConnected" />

        <label for="ServerNameOrAddress">Server Address: </label>
        <input id="ServerNameOrAddress" type="text" @bind="ServerNameOrAddress" disabled="@network.IsConnected" />

        <label for="ServerPort">Port: </label>
        <input id="ServerPort" type="number" @bind="ServerPort" disabled="@network.IsConnected" />

        @if (network.IsConnected)
        {
            <button class="btn btn-primary" @onclick="DisconnectFromServer">Disconnect</button>
        }
        else
        {
            <button class="btn btn-primary" @onclick="ConnectToServer">Connect</button>
        }

    </div>
</div>

<!-- Canvas for Game Display -->
<div id="snakeCanvas" style="position: fixed; width: 100%; height: 100%">
    <BECanvas Width="1000" Height="1000" @ref="canvasReference"></BECanvas>
</div>

<!-- Connection -->
@code
{

    // Connection
    private string ServerNameOrAddress = "localhost";
    private int ServerPort = 11000;

    // Player
    private string PlayerName { get; set; } = string.Empty;

    // Network
    private NetworkController networkController;

    private async Task ConnectToServer()
    {
        if (!network.IsConnected)
        {
            try
            {
                network.Connect(ServerNameOrAddress, ServerPort);
                network.Send(PlayerName);
                networkController = new NetworkController(network);
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Failed to connect: {ex.Message}");
            }
        }
    }

    private void DisconnectFromServer()
    {
        if (network.IsConnected)
        {
            network.Disconnect();
            Console.WriteLine("Disconnected from server.");
        }
    }

}

<!-- User Input -->
@code
{

    [JSInvokable]
    public void HandleKeyPress(string key)
    {

        // Only works if IsConnected
        if (!network.IsConnected)
        {
            return;
        }

        // Map the key to a movement direction
        string direction = key switch
        {
            "w" => "up",
            "a" => "left",
            "s" => "down",
            "d" => "right"
        };

        // If the direction is valid, send it to the NetworkController
        if (direction != null && networkController != null)
        {
            // Create a ControlCommand object with the direction
            ControlCommand command = new ControlCommand(direction);

            // Send the command to the server through NetworkController
            networkController.SendCommand(command);
        }
    }

}

<!-- Rendering Game State -->
@code
{

    // Canvas
    private BECanvasComponent canvasReference = null!;
    private Canvas2DContext context = null!;
    private IJSObjectReference jsModule = null!;
    private NetworkConnection network = new NetworkConnection();

    private ElementReference backgroundImage;

    // World
    private World TheWorld = new(WorldSize);
    private const int ViewWidth = 1000;
    private const int ViewHeight = 1000;
    private const int WorldSize = 1000;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            jsModule = await JsRuntime.InvokeAsync<IJSObjectReference>("import", "./Pages/SnakeGUI.razor.js");
            context = await canvasReference.CreateCanvas2DAsync();
            await JsRuntime.InvokeAsync<object>("initRenderJS", DotNetObjectReference.Create(this));

            // Start the game loop
            //await GameLoop();
        }
    }

    private async Task GameLoop()
    {
        while (true)
        {
            // Create a snapshot of the current world state to avoid modifying the shared resource.
            World snapshot = new World(WorldSize);

            await DrawFrame(snapshot);

            Thread.Sleep(20);
        }
    }

    private async Task DrawFrame(World snapshot)
    {

        // batch the drawing calls for better performance
        await context.BeginBatchAsync();

        await context.DrawImageAsync(backgroundImage, 0, 0, ViewWidth, ViewHeight);

        // Draw each snake, powerup, and wall

    }

    private async Task DrawSnake(Snake snake)
    {

    }

    private async Task DrawPowerup(Powerup powerup)
    {

    }

    private async Task DrawWall(Wall wall)
    {

    }

}